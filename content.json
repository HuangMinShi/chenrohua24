{"pages":[{"title":"about","text":"","link":"/chenrohua24/about/index.html"},{"title":"categories","text":"","link":"/chenrohua24/categories/index.html"}],"posts":[{"title":"理解 Event Loop","text":"Target理解並敘述 Event Loop 是什麼？ Contents JavaScript in browser JavaScript Engine Event Loop Zero delays Conclusion References JavaScript in browser網路應用程式包含了很多技術，並且共同組成 JS Runtime Environment 。除了由 JavaScript Engine 負責解析程式碼之外，瀏覽器也提供了許多 Web API 像是 DOM, setTimeout 來與使用者進行互動，以及等等會提到的 Event Loop, Event Queue and Event Table。而透過 Event Loop 搭配非同步的方式進而達成 JavaScript 能同時處理多個工作的錯覺。 JavaScript Engine it’s job is to go through all the lines of JavaScript in an application and process them one at a time JavaScript Engine 所做的事情，是去遍歷應用程式當中每一行程式碼，而且一次執行一段。這同時也注定了 JavaScript 是單線程（single threaded）的程式語言。 那麼 JavaScript Engine 如何做到一次只執行一段？它利用了 Call Stack 去記錄目前程式執行的部分。 Call Stack 是一種具有先進後出（FILO, First-in-Last-out）性質的有序串列，就像搭電梯一樣，第一個進電梯的人會最後出電梯，最後進電梯的則最先出來。因此程式執行時會層層往上疊，而執行結束後層層跳離（pop off）。舉個例子： 12345678910111213141516/* main.js */const one = () => { console.log('1')}const two = () => { one() console.log('2')}two()/* Results:* => 1* => 2*/ 流程： 執行全域環境的程式 main.js 調用 two 引起 one 被調用 執行 one ，console 輸出 ‘1’，此時 one 無其他程式碼，執行完畢從 Call Stack 跳離（pop off） 執行 two ，console 輸出 ‘2’，此時 two 無其他程式碼，執行完畢從 Call Stack 跳離（pop off） 最後 main.js 也沒有其他程式碼可執行，執行完畢從 Call Stack 跳離（pop off） Javascript Call Stack demo 上述其中一個程式碼片段若需要執行非常久的時間，則後面的程式碼就會等待執行，好像卡住一樣，這樣的情況稱作阻塞 （blocking）。 例如請求資料的 AJAX request，如果是以同步方式執行的話，因為必須等待伺服器回應，才能從 Call Stack 跳離（pop off）。還沒接收回應前整個瀏覽器頁面停滯，即使點了其他 button，瀏覽器就只是掛在那裡，不會有任何反應。 Event Loop如何避免阻塞？ JavaScript provides a mechanism and it’s via asynchronous callback functions. 非同步搭配 Callback Function，常見於將函式當成參數傳進另外一個函式之中，而這些被傳進的函式並沒有馬上被執行，而是等待條件觸發後才執行。 底下以 setTimeout 為例。setTimeout 函式是瀏覽器提供的 API ，不是 JavaScript Engine 本身的功能，當調用 setTimeout 函式時，瀏覽器會提供一個計時器用來計時秒數。1234567891011121314151617/* Within main.js */const one = () => { console.log('1')}const two = () => { setTimeout(one, 5000) console.log('2')}two();/* Results: * => 2 * (And 5 seconds later) * => 1 */ …（如上個例子所述） 執行 two，並調用 setTimeout，setTimeout 進入 Call Stack 執行 setTimeout，Call Stack 向 Event Table 註冊 Callback Function （one），並同時記錄觸發事件，也就是等待 5 秒。 Event Table 就是個註冊站，Call Stack 讓 Event Table 註冊一個特定函式（在這裡為 one）以及觸發的事件（wait 5000 ms）。當事件發生，Event Table將對應的函式移到 Event Queue 等待被調用。而 Event Queue 就像是個暫存區，依序存放著等待被調用至 Call Stack 的函式。並且具有先進先出（FIFO, First-in-First-out）的性質，就如同排隊，先排到的先買到。 那麼何時會被調用至 Call Stack ？ JavaScript Engine 利用 Event Loop 機制來解決何時會被調用的問題。這個處理程序將不斷地檢查 Call Stack 當中是否已清空，若清空，則檢查 Event Queue 是否有等待被調用的函式，如果有，則將第一個等待被調用的函式移至 Call Stack 執行。如果沒有，仍不斷地反覆檢查 Call Stack 及 Event Queue。這個監控的過程就是 Event Loop，就像 While Loop 一樣不停的運作。接續上述例子： setTimeout 執行完畢跳離（pop off）Call Stack，此時 Call Stack 將不再有阻塞情形，所以 two 繼續執行下一行， console 輸出 ‘2’ two 執行完畢，跳離（pop off）Call Stack，而後 main.js 也是一樣。此時 Event Table 仍於背景持續監控是否有任何已註冊事件發生 5 秒鐘過去，等待 5秒的事件完成，Event Table 將剛剛註冊的 Callback Function （one）移至 Event Queue Event Loop 也是不斷地在監控 Call Stack 及 Event Queue。一旦確認 Call Stack 為空後，且 Event Queue 也有一個等待被調用的函式，於是將這個函式 one 轉移至 Call Stack 執行。one 執行，console 輸出 ‘2’，並且執行完畢，跳離 Call Stack。 JavaScript Event Loop with setTimeout demo Zero delays如果上述例子使用 setTimeout 並且希望在 0 秒後馬上執行，會是一樣的結果嗎？ 1234567891011121314151617/* Within main.js */const one = () => { console.log('1')}const two = () => { setTimeout(one, 0) console.log('2')}two();/* Results: * => 2 * (And 0 seconds later) * => 1 */是的，即使 0 秒，它一樣會先將 Callback Function 註冊到 Event Table 中，並計時 0 秒，時間到，再把 Callback Function 放到 Event Queue，藉由 Event Loop 的機制等到所有 Call Stack 的內容清空後，而且 Event Queue 當中前面無其他的待處理事件時，才會立即執行這個 Callback Function。 因此 setTimeout 的時間表示的是執行的最少等待時間，並非保證會被執行的時間。 ConclusionEvent Loop 是一種機制，不斷地監控 Call Stack 及 Event Queue，如同一個無限迴圈。一旦 Call Stack 清空，則把 Event Queue 裡，第一個待執行函式移到 Call Stack 執行。而透過這個機制，搭配非同步方法進而快速切換並處理多項工作，而不再只是卡著不動了。 References並行模型和事件循環 - MDNWhat is the JavaScript event loop?Philip Roberts: What the heck is the event loop anyway?","link":"/chenrohua24/2020/10/27/event-loop/"},{"title":"[MySQL] 如何排序名次 #2","text":"目標於 MySQL 中宣告使用者變數 、利用 IF 條件判斷並考量名次並列情形，正確排序飲料銷售量名次。 無名次並列延續上一篇的情境，一樣假設有飲料及訂單 2 張資料表，定義欄位如下 ： 12drinks : id, name, priceorders : id, quantity, drink_id 想知道哪種飲料銷售量最高？SQL 語法如下： 12345678910111213141516171819202122232425262728-- 宣告使用者變數及賦值SET @prev = null, @curr = null, @rank = 0;SELECT b.`name`, b.`total_quantity`, b.`rank`FROM ( -- 條件判斷名次 SELECT a.*, @prev := @curr, @curr := a.`total_quantity`, @rank := IF(@prev = @curr, @rank, @rank + 1) AS rank FROM ( -- 子查詢計算總銷量 SELECT drinks.`name`, SUM(`quantity`) AS `total_quantity` FROM orders JOIN drinks ON drinks.`id` = orders.`drink_id` GROUP BY `drink_id` ORDER BY `total_quantity` DESC ) AS a) AS b;view rawrank.sql hosted with ❤ by GitHub 初始化line 2：宣告 3 個使用者變數 @prev, @curr, @rank，分別儲存前值、當前值及名次，而變數的命名形式是 @變數名。 從第三層非相關子查詢開始line 17– 26 ： 由 orders 去 JOIN drinks，按 drink_id 分組，再由 SELECT 加總銷售量，最後降冪排序，表格別名取為 a 返回第二層。 第二層子查詢line 13：@curr 的值賦予給 @prevline 14：將第三層計算好的總銷售量 a.total_quantity 賦值給 @currline 15：如果前值跟當前值不相等，則 @rank 加 1 再賦值給 @rank 第一層主查詢重複 line 13 -15 直到所有紀錄 （records） 執行完畢。最後帶著 a 表格的全部欄位，取名為 b 奔回第一層，由 SELECT 篩選欄位。 name total_quantity rank 緋聞紅茶 21 1 不熟紅茶 21 1 雪花冷路 20 2 中正路路 12 3 莉莉紅茶 4 4 新芽紅茶 2 5 春天冷路 2 5 中山路咩 1 6 但結果跟預期的有點不太一樣。因為我預期的是當遇到 2 種飲料名次並列時，名次保持不變，但仍佔有位置，例如（1, 2, 2, 2, 5）而非（1, 2, 2, 2, 3）。如飲料查詢結果中的雪花冷路，它的名次應該是 3 才是。 有名次並列為解決上述問題，額外再新增第 4 個變數 @temp 去記錄 loop 的次數，一但遇到並列，雖然名次不變，但紀錄次數仍持續加 1 ，直到沒有並列問題，再把 @temp 賦值給 @rank 修改後如下： 12345678910111213141516171819202122232425262728-- 宣告使用者變數及賦值SET @prev = null, @curr = null, @rank = 0, @temp = 0;SELECT b.`name`, b.`total_quantity`, b.`rank`FROM ( -- 條件判斷名次 SELECT a.*, @temp := @temp + 1, @prev := @curr, @curr := a.`total_quantity`, @rank := IF(@prev = @curr, @rank, @temp) AS rank FROM ( -- 子查詢計算總銷量 SELECT drinks.`name`, SUM(`quantity`) AS `total_quantity` FROM orders JOIN drinks ON drinks.`id` = orders.`drink_id` GROUP BY `drink_id` ORDER BY `total_quantity` DESC ) AS a) AS b; 修改部分：line 2 ：新增 @temp 變數line 13：@temp +=1line 16：若兩者銷售量不相等，即沒有並列情形，則將 @temp 賦值給 @rank name total_quantity rank 緋聞紅茶 21 1 不熟紅茶 21 1 雪花冷路 20 3 中正路路 12 4 莉莉紅茶 4 5 新芽紅茶 2 6 春天冷路 2 6 中山路咩 1 8 總算是正確顯示名次資訊了。 結論相較上一篇，本篇以另一種方式列出名次，利用宣告使用者變數及排序後的總銷售量資料表，逐筆針對前值及當前值做條件判斷，若相等，名次保持不變；若不等則名次加 1。然而考量到並列情形，須再宣告另一變數 temp 儲存 loop 的次數值，相等，名次依舊保持不變；不相等，紀錄次數賦值給名次，達成像（1, 2, 2, 4, 5）的期望名次顯示。 值得一提的是，上述在開頭利用 SET 方式宣告並賦予初始值的使用者變數，其賦值運算子可以使用 = 或 := e.g. SET @test := 1; 而另一種賦值的方式常見於 SELECT e.g. SELECT @test1, @test2 := 2;，但只能用 := 作為賦值運算子。WHY？ 因為 = 出了 SET 這個語句之後，將被視為比較運算子而非賦值運算子。另外這樣的方式可能會於未來版本的 MySQL 中刪除，請注意。 參考MySQL DOCUMENTATIONMySQL排序名次、排行(使用SQL語法排序)","link":"/chenrohua24/2019/10/17/how-to-rank-in-mysql-2/"},{"title":"[MySQL] 如何排序名次 #1","text":"目標於 MySQL 中利用 SELF JOIN，並設定 ON 參考點的符合條件，正確排序飲料銷售量名次。 情境回顧自己在 AC 學期三 MySQL 伺服器上學習 SQL 語法時，遇到一個實境章節是建立飲料店的資料庫，在此簡單假設有飲料及訂單 2 張資料表，飲料有編號（id）、名稱（name）及價格欄位（price），訂單則有編號（id）、銷售量（quantity）及飲料編號（drink_id）。 12drinks : id, name, priceorders : id, quantity, drink_id 現在想像飲料店老闆想知道目前銷售量最高的飲料是哪一種？身為最有效率員工的你並沒有想的太多，很快查詢出銷售量最高的飲料就是緋聞紅茶。 12345678SELECT drinks.`name`, SUM(`quantity`) AS `total_quantity`FROM ordersJOIN drinks ON orders.`drink_id` = drinks.`id`GROUP BY `drink_id`ORDER BY `total_quantity` DESCLIMIT 1; name total_quantity 緋聞紅茶 21 只有緋聞紅茶嗎？老闆略帶狐疑地再問一次，你扭扭捏捏地回應著「是阿．．．」，雖然你嘴上這樣說，但你心裡開始不安了起來。萬一店裡的不熟紅茶也剛好賣 21 杯，那麼銷售量最好的就不是只有一種，此時的你也只講對了一半，這樣的微小錯誤，未來可能產生蝴蝶效應，而導致老闆決策方向錯誤甚至虧損，相信這不是身為一個社畜扛的起。 問題面對上述諸如此類，排山倒海而來的恐慌及壓力，你勢必要了解各種飲料的銷售量排行，好讓你能一目了然是否有並列第一的情況。為此，我們的目標是針對各種飲料的銷售量排序並呈現出正確名次，這裡的問題是如何排名？ name total_quantity rank 緋聞紅茶 21 1 不熟紅茶 21 1 雪花冷路 20 3 中正路路 12 4 莉莉紅茶 4 5 新芽紅茶 2 6 春天冷路 2 6 中山路咩 1 8 解決 MySQL 內建的函式 RANK()？就在閱讀官方技術文件後，發現只有 MySQL 8.0 才支援 RANK()，如果使用的是 5.6 還是得自己生出一個。有道是凡事做最好準備，最壞打算，這裡我們就不使用 RANK()了。 單純使用查詢語法搭配 WHERE 關鍵字及運算子來計算名次？首先將例子簡單及縮小化，以同學分數排名做範例。之後再丟回來也不遲。 name score rank A 90 1 B 80 2 C 70 3 D 60 4 E 50 5 這裡想知道的是 E 同學為何排名 5？因為 A, B, C, D 等 4 位同學分數高於 E。D 同學為何排名 4？因為 A, B, C 等 3 位同學分數高於 D。 請問施主，參透出什麼洞見了嗎？ 沒錯，只要找出大於等於自己分數的個數，就是該位同學的名次。 知道名次從何而來，接下來的問題是如何比對分數，而從過程當中發現，比來比去其實就同一個班級同學的分數互做比較，而在同一張表裡互相比對可以使用 SELF JOIN，自己跟自己合併。有了概念後再拉回來飲料店的例子，你迫不及待地快速寫下步驟及語法。 將訂單以飲料 ID 分組，加總 quantity 後按 total_quantity 降冪排序。 將上述查詢後的資料表，採 SELF JOIN，並分別命名為 a 及 b。 從 a 資料表的角度思考，其參考點設為 b.total_quantity 大於等於 a.total_quantity，意思是誰的銷售量大於等於我。 一樣是站在 a 資料表的角度，去計算大於等於 a.total_quantity 的個數當作排名的欄位。 123456789101112131415161718192021222324252627SELECT a.`name`, a.`total_quantity`, COUNT(b.`total_quantity`) AS rankFROM ( SELECT drinks.`name`, SUM(`quantity`) AS total_quantity FROM orders LEFT JOIN drinks ON orders.`drink_id` = drinks.`id` GROUP BY `drink_id` ORDER BY total_quantity DESC) AS aJOIN ( SELECT drinks.`name`, SUM(`quantity`) AS total_quantity FROM orders LEFT JOIN drinks ON orders.`drink_id` = drinks.`id` GROUP BY `drink_id` ORDER BY total_quantity DESC) AS bON a.`total_quantity`","link":"/chenrohua24/2019/10/16/how-to-rank-in-mysql-1/"},{"title":"以 xlsx-style 處理 Excel 文件","text":"目標本文學習利用 Node.js 第三方套件 xlsx-style，處理 Excel 文件。首先釐清使用者期望輸出結果來界定目標，中間介紹套件的基本概念及用法，最後實做流程為匯入試算表、萃取資訊、處理轉換資料、計算有效範圍到匯出。 問題情境某日 Nicole 即將開會，手上有空白座位表及與會人員清單，希望指定人員至特定座位，並匯出座位表張貼至會議室外牆做導引。難道得從人員清單一位一位的複製貼上至座位表？ 因此指派位置欄位，依據指定位置輸出人員特定資訊，並附加基本格式為本案的實作目標。最後輸出的 Excel 形式如下： 認識套件 xlsx-style物件 workbook 為活頁簿，藉由 xlsx-style 讀取 Excel 檔案獲得。 worksheet 為活頁簿當中的工作表。 cell 為儲存格，如 A12, B7。 常用屬性鍵有 v 原始值，t 類型及 s 格式。 三者關係如下： 1234567891011121314151617181920212223242526272829// workbook{ SheetNames: ['sheet1', 'sheet2'], Sheets: { // worksheet sheet1: { // cell A1: { ... }, // cell A2: { ... }, }, // worksheet sheet2: { // cell A1: { ... }, // cell A2: { // cell type 為 String t: 's', // raw value 原始值 v: '金剛戰士', // style s: { border: {} } }, } }} 用法 XLSX.readFile 讀取 Excel 文件，返回 workbook const workbook = XLSX.readFile('excel.xlsx', opts) workbook.SheetNames 取得工作表名 array const sheetNames = workbook.SheetNames // 返回 ['sheet1', 'sheet2'] workbook.Sheets[Sheetname] 取得工作表 const worksheet = workbook[sheetNames[1]] XLSX.utils.sheet_to_json 轉換 worksheet 物件至 JSON 物件 const objOfJson = XLSX.utils.sheet_to_json(worksheet) worksheet[address] 取得 cell 物件 const b2 = worksheet['B2'] // 返回 { v: '金剛戰士', t: 's', s: {...}} worksheet['!ref'] 取得工作表有效範圍 worksheet['!ref'] // 返回 'A1:B2' XLSX.writeFile 匯出 Excel 文件 XLSX.writeFile(wb, 'newExcel.xlsx') 實作流程目前使用者已有空白座位表及與會人員清單。首先於清單新增 1 行並填入想指定的 position。其次定義每個座位須包含 4 個儲存格，儲存格由上至下將依序顯示人員編號、所屬公司、職業及名字（no, company, job, name）。 實作方面則拆解為格式及內容 2 部分。格式包含標題、框線、座位及會議室環境的配置（門及講台），內容則為人員資訊，緊接著編寫程式碼的步驟如下： 載入 Excel 中的 2 張工作表，分別為 空白座位 worksheet 與會人員 worksheet 轉換 worksheets 以方便處理資料 過濾空白座位 worksheet ，返回儲存每張座位第 1 個儲存格的 array 轉換與會人員 worksheet ，返回 JSON 物件 處理轉換後的 worksheets 依據配置寫入標題及框線，產生會議室的 template worksheet 依據人員資訊及指定的座位，產生人員的 data worksheet 合併 template 及 data ，返回 output worksheet 計算 output worksheet 的有效範圍 生成 workbook 生成 Excel 檔案 程式碼主執行 - main.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/*====================== 基本設定========================*/const XLSX = require('xlsx-style')const { genTemplate, genData } = require('./libs/generate')const { xlsxToJson, getRange, merge } = require('./libs/func')// 宣告變數const display = ['no', 'company', 'job', 'name']const config = { header: { value: '第70屆金鐘獎頒獎典禮工作會議', position: 'E2:E2' }, location: { value: '會議室座位表', position: 'J4:J4' }, door1: { value: '門', position: 'B37:C38' }, door2: { value: '門', position: 'V37:W38' }, lectern: { value: '講台', position: 'I37:N38' }}/*====================== 執行========================*/// 讀取 Excel 匯出 worksheetsconst workbook = XLSX.readFile('./excels/conference.xlsx', { cellStyles: true })const worksheet = workbook.SheetNamesconst _seats = workbook.Sheets[worksheet[0]]const _students = workbook.Sheets[worksheet[1]]// 處理 worksheets（過濾 _seats to array；轉換 _students to JSON）const keys = Object.keys(_seats)const seats = keys.filter(key => { return (key.charAt(0) !== '!' && _seats[key].v)})const { content } = xlsxToJson(_students)// 處理使用者需求並合併為 worksheet objectconst template = genTemplate(config, seats, display.length - 1)const data = genData(content, display)const output = merge(template, data)// 範圍const ref = getRange(output)// 生成 workbookconst wb = { SheetNames: ['sheet_1'], Sheets: { 'sheet_1': { '!ref': ref, // 若無範圍，則只會產出空表而已 ...output } }}// 生成 Excel 文件XLSX.writeFile(wb, './excels/output.xlsx') 功能函式 - func.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156// 取得 cell 行列如 A1 => {A,1}const getColAndRow = (cell) => { // col 位數 let index = cell.split('').findIndex(value => { return !isNaN(value) }) // 如 A21 中的 A const col = cell.substr(0, index) // 如 A21 中的 21 const row = parseInt(cell.substr(index)) return { col, row }}// 解析 xlsx 返回 {headers, data}const xlsxToJson = (worksheet) => { const _headers = {} const content = [] const keys = Object.keys(worksheet) keys // 過濾非'!'開頭的 keys .filter(k => k.charAt(0) !== '!') .forEach(k => { const { col, row } = getColAndRow(k) // 當前 cell 的值 const value = worksheet[k].v // 第一列為 headers if (row === 1) { _headers[col] = value return } // 解析 data const index = row - 2 if (!content[index]) { content[index] = {} } content[index][_headers[col]] = value }) // const headers = Object.values(_headers) return { headers, content }}// 畫外框線，如 A1:C3 的正方形外框const drawFieldsBorder = (start, end) => { const startCR = getColAndRow(start) // {A, 1} const endCR = getColAndRow(end) // {C, 3} const startCol = startCR.col // A const startRow = startCR.row // 1 const endCol = endCR.col // C const endRow = endCR.row // 3 const startChar = start.charCodeAt() // 65 const endChar = end.charCodeAt() //67 const result = {} /* 外框選項 { A:'left', C:'right', '1':'top', '3':'bottom' } */ const opts = { [startCol]: 'left', [endCol]: 'right', [startRow]: 'top', [endRow]: 'bottom' } for (let c = startChar; c { return getColAndRow(cell).col }).sort() const startCol = cols[0] const endCol = cols[cols.length - 1] // 列 const rows = cellsArr.map(cell => { return getColAndRow(cell).row }).sort((a, b) => a - b) const startRow = rows[0] const endRow = rows[rows.length - 1] return `${startCol + startRow}:${endCol + endRow}`}// 合併 template 及 dataconst merge = (template, data) => { const dataCells = Object.keys(data) const error = [] dataCells.forEach(cell => { if (!template[cell]) { error.push(data[cell]) } else { template[cell].v = data[cell].v } }) if (error.length) return error return template}module.exports = { getColAndRow, xlsxToJson, drawFieldsBorder, getRange, merge} 生成 template 及 data 函式 - generate.js123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102const { getColAndRow, drawFieldsBorder } = require('./func')/* 解析 JSON 生成 data 如{ P8: { v: 1 }, P9: { v: '喬傑立娛樂' }, P10: { v: '歌手' }, P11: { v: '孫協志' }, T6: { v: 2 }, T7: { v: '三立藝能' }, T8: { v: '演員' }, T9: { v: '紀言愷' },}*/const genData = (json, display) => { const data = json .map(item => { const { col, row } = getColAndRow(item.position) // 返回依 display 順序顯示的欄位 return display.map((key, index) => { const position = col + (row + index) // 返回 worksheet object return { [position]: { v: item[key] } } }) }) // 降維 .reduce((prev, curr) => { return prev.concat(curr) }) .reduce((prev, curr) => { return Object.assign({}, prev, curr) }) return data}/* 生成 template 如{ E2: { v: '第70屆金鐘獎頒獎典禮工作會議', s: { font: [Object] } }, J4: { v: '會議室座位表', s: { font: [Object] } }, B37: { s: { border: [Object], font: [Object] }, v: '門' },}*/const genTemplate = (config, seats, cellsPerSeat) => { // 畫出配置 const c = Object.keys(config) .map(key => { const item = config[key] const start = item.position.split(':')[0] const end = item.position.split(':')[1] // 門及講台的儲存格畫框線 if (key === 'door1' || key === 'door2' || key === 'lectern') { const fieldsHasBorder = drawFieldsBorder(start, end) fieldsHasBorder[start].v = item.value fieldsHasBorder[start].s['font'] = { sz: '16', bold: true } return fieldsHasBorder } return { [start]: { v: item.value, s: { font: { sz: '24', bold: true } } } } }) .reduce((prev, curr) => { return Object.assign({}, prev, curr) }) // 畫出座位 const s = seats .map(start => { const { col, row } = getColAndRow(start) const end = col + (row + cellsPerSeat) return drawFieldsBorder(start, end) }) .reduce((prev, curr) => { return Object.assign({}, prev, curr) }) // 返回合併後的配置及座位 return Object.assign({}, c, s)}module.exports = { genTemplate, genData} 結論實作過程接連遇到許多小插曲，例如原先以 js-xlsx (community version) 處理，不過程式碼寫到一半發現無法寫入框線格式，怎麼辦？棄用？而翻了 github 上的 issue，更加證實自己目前遇到的窘境。當然後面只能另外尋找套件，也發現了 xlsx-style 支援寫入，不過僅支援簡單格式上的操作，如字體大小、框線、儲存格填滿，不過現階段也夠用了，相當符合本案需求。 第二個問題發生在處理及轉換資料的階段，文中所述想法是分為格式及資料兩部分產生後合併，但當我寫完格式部分後，忽然有莫名的念頭閃過，其實格式可以不用自己產生阿！畢竟一開始使用者就有空白座位表的資訊，只要讀取檔案時一併匯入就好 XLSX.readFile('Excel.xlsx', { cellStyles: true }) WTF～但我做完了耶！哎呀～不過換個想法，假如目前情況改成使用者沒有空白座位表的資訊時，勢必也得自己從無到有，這樣子練習一下也好，總算舒服許多。 參考sheetjsxlsx-style在 Node.js 中利用 js-xlsx 处理 Excel 文件","link":"/chenrohua24/2019/10/23/use-xlsx-style/"}],"tags":[],"categories":[]}